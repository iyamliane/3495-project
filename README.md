# Video Streaming Project (Demo)

Our service implements a simple video upload and streaming flow using Docker Compose. It is built for local development and learning, not production.

## Overview

- Architecture: microservices orchestrated by `docker-compose`.
- Core services:
  - `auth_service` — Flask (Python) for register/login (stores `users.json` in the container; CORS enabled for the demo).
  - `upload_service` — Node/Express handles the upload UI and multipart file uploads; saves files into a shared `/videos` volume and writes a DB record.
  - `streaming_service` — Node/Express exposes `/videos` (DB list) and `/stream/:filename` with HTTP Range support for playback/seeking.
  - `file_system_service` — Flask helper with `/save` and `/read/<filename>` (kept as fallback; most file handling uses the shared volume).
  - `mysql` — MySQL 8 database (`videos_db`) to store upload metadata.

Files uploaded via the `upload_service` are stored on the host at `./videos` and are visible to services mounted to that volume.

## Where to look (important files)

- `docker-compose.yml` — service definitions, volumes, and ports.
- `auth_service/` — `app.py`, `requirements.txt`; `users.json` (created at runtime inside the container).
- `upload_service/` — `server.js`, `package.json`, `public/` (UI):
  - `public/index.html` — upload page (drag & drop, progress bar)
  - `public/videos/index.html` — videos listing/playback UI
- `streaming_service/` — `server.js`, `package.json` (Range-aware streaming and `/videos` API).
- `file_system_service/` — `app.py`, `requirements.txt` (fallback read/save endpoints).

## Ports

- Upload UI: http://localhost:3000/
- Streaming API: http://localhost:4000/
  - `/videos` — JSON list of uploaded videos
  - `/stream/:filename` — stream bytes with Range support
- Auth API: http://localhost:5000/
  - `/login`, `/register`
- File system service (fallback): http://localhost:5003/
- MySQL (host port): 3307 (maps to 3306 in the container)

Credentials for demo MySQL:

- User: `root`
- Password: `root`
- Database: `videos_db`

## How it works (upload -> stream)

1. User uploads a file from the browser to `upload_service` (`POST /upload` multipart form).
2. `multer` (upload_service) stores the file as `/videos/<generatedFilename>` in the shared host volume.
3. `upload_service` inserts a row into the MySQL `videos` table with `username`, `filename` (original name), and `path` (generated filename only — basename).
4. Browser visits the videos UI (served at `/videos`) which fetches `GET http://localhost:4000/videos` and displays cards.
5. When playing, the UI uses `<video src="http://localhost:4000/stream/<path>">`. `streaming_service` serves bytes and honors Range requests (so seeking works).

## Data model (simple)

Table: `videos`

- `id` INT AUTO_INCREMENT PRIMARY KEY
- `username` VARCHAR
- `filename` VARCHAR  (original uploaded name)
- `path` VARCHAR      (stored basename generated by multer)
- `created_at` TIMESTAMP

## Quick start (PowerShell)

1. From project root:

```powershell
Set-Location 'C:\Users\leean\acit3495\Project1\video_streaming_project'
docker compose up --build -d
```

2. Open the upload UI:

```text
http://localhost:3000/
```

3. Upload a file (example curl for testing):

```powershell
Set-Content -Path .\test.txt -Value 'hello'
curl.exe -F "username=leeanne" -F "video=@test.txt" http://localhost:3000/upload
```

4. Browse uploaded videos:

```text
http://localhost:3000/videos/
```

5. Inspect DB rows (from host):

```powershell
docker compose exec -T mysql mysql -uroot -proot -e "SELECT id,username,filename,path,created_at FROM videos ORDER BY id DESC LIMIT 10" videos_db
```

## Useful API endpoints

- Auth:
  - `POST /login` — JSON body {username, password}
  - `POST /register` — JSON body {username, password}
- Upload service:
  - `POST /upload` — multipart/form-data {username, video}
  - `GET /` — upload UI
  - `GET /videos` — videos UI (static page)
- Streaming service:
  - `GET /videos` — returns DB rows (JSON)
  - `GET /stream/:filename` — stream content with Range support

## Troubleshooting

- Docker Compose complains about `version` in `docker-compose.yml`: the compose V2 plugin ignores the `version` field — safe to remove.
- If Node services log `ECONNREFUSED` to MySQL: the Node services include a `waitForDb()` retry that should handle start races, but ensure MySQL started and listen on mapped port.
- If uploads appear in a container but other services cannot read them: make sure `./videos` is mounted into both `upload_service` and `streaming_service` in `docker-compose.yml`.
- If browser login returns "failed to fetch": confirm `auth_service` has CORS enabled and is reachable at port 5000.

## Security & production notes (important)

This demo is intentionally simple. Do not use it as-is in production:

- Passwords are currently stored in plaintext in `auth_service/users.json`. Replace with hashed passwords (e.g., `bcrypt`) immediately for any real use.
- Authentication is not enforced for upload or streaming. Implement JWT/session tokens and require them for sensitive endpoints.
- Flask apps run with the development server. Use a WSGI server such as `gunicorn` in production.
- For real video delivery, use HLS/DASH or a CDN. HTTP byte-range streaming works for small demos but is not optimized for large-scale delivery.

## Next recommended improvements

1. Hash passwords (bcrypt) and update `/register` and `/login` flows.  
2. Issue JWT tokens on login and require Bearer tokens for `/upload` and `/stream`.  
3. Use `mime` package to set correct `Content-Type` in `streaming_service`.  
4. Add Range caching, larger chunk tuning, and streaming optimization.  
5. Add unit tests and CI for auth/upload flows.  

## Development notes / logs

- During development we fixed several issues:
  - Pinned `multer` to avoid npm registry resolution errors.
  - Ensured Flask dependencies (Flask, flask-cors) are installed.
  - Added DB readiness retry logic in Node services to avoid startup races.
  - Mounted the `./videos` host directory into containers so files are visible across services.
  - Implemented HTTP Range support in `streaming_service` to enable seeking in the browser.

## Contributing / extending

If you want me to implement any of the recommended improvements (bcrypt, JWT, HLS conversion, thumbnail generation, or tests), tell me which one and I will implement it and update this README with any new instructions.

---
Generated on: October 16, 2025
